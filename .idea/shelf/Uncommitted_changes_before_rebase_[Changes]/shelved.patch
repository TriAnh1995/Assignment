Index: api/internal/repository/check_user_by_email_test.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package repository\r\n\r\nimport (\r\n\t\"assignment/internal/repository/testdata\"\r\n\t\"context\"\r\n\t\"database/sql\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/DATA-DOG/go-sqlmock\"\r\n\t\"github.com/friendsofgo/errors\"\r\n\t\"github.com/stretchr/testify/require\"\r\n)\r\n\r\nfunc TestImpl_CheckUserByEmail(t *testing.T) {\r\n\r\n\ttestCases := []struct {\r\n\t\tName          string\r\n\t\tWantDBFail    bool\r\n\t\tUserEmail     string\r\n\t\tExpectedExist bool\r\n\t\tExpectedErr   error\r\n\t}{\r\n\t\t{\r\n\t\t\tName:          \"Success\",\r\n\t\t\tWantDBFail:    false,\r\n\t\t\tUserEmail:     \"new-user-email@example.com\",\r\n\t\t\tExpectedExist: false,\r\n\t\t\tExpectedErr:   nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tName:          \"User Already Exist\",\r\n\t\t\tWantDBFail:    false,\r\n\t\t\tUserEmail:     \"already-exist-email@example.com\",\r\n\t\t\tExpectedExist: true,\r\n\t\t\tExpectedErr:   nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tName:          \"Internal Server Error\",\r\n\t\t\tWantDBFail:    true,\r\n\t\t\tUserEmail:     \"internal-error-email@example.com\",\r\n\t\t\tExpectedExist: false,\r\n\t\t\tExpectedErr:   errors.New(\"orm: failed to check if user_accounts exists: all expectations were already fulfilled, call to Query 'SELECT COUNT(*) FROM \\\"user_accounts\\\" WHERE (\\\"user_accounts\\\".\\\"email\\\" = $1) LIMIT 1;' with args [{Name: Ordinal:1 Value:internal-error-email@example.com}] was not expected\"),\r\n\t\t},\r\n\t}\r\n\r\n\tctx := context.Background()\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.Name, func(t *testing.T) {\r\n\r\n\t\t\ttestdata.TestDatabase(t, func(tx *sql.Tx) {\r\n\r\n\t\t\t\ttestdata.LoadTestSQLFile(t, tx, \"testdata/testdata_for_user_accounts.sql\")\r\n\r\n\t\t\t\trepo := New(tx)\r\n\t\t\t\tif tc.WantDBFail {\r\n\t\t\t\t\tdbMock, _, _ := sqlmock.New()\r\n\t\t\t\t\trepo = New(dbMock)\r\n\t\t\t\t}\r\n\r\n\t\t\t\texists, err := repo.CheckUserByEmail(ctx, tc.UserEmail)\r\n\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\trequire.EqualError(t, err, tc.ExpectedErr.Error())\r\n\t\t\t\t} else {\r\n\t\t\t\t\trequire.Equal(t, tc.ExpectedExist, exists)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/internal/repository/check_user_by_email_test.go b/api/internal/repository/check_user_by_email_test.go
--- a/api/internal/repository/check_user_by_email_test.go	(revision 16bdd12a1d72b35622c8ef226fccdc68eeb14ec5)
+++ b/api/internal/repository/check_user_by_email_test.go	(date 1699237267968)
@@ -7,7 +7,6 @@
 	"testing"
 
 	"github.com/DATA-DOG/go-sqlmock"
-	"github.com/friendsofgo/errors"
 	"github.com/stretchr/testify/require"
 )
 
@@ -39,7 +38,7 @@
 			WantDBFail:    true,
 			UserEmail:     "internal-error-email@example.com",
 			ExpectedExist: false,
-			ExpectedErr:   errors.New("orm: failed to check if user_accounts exists: all expectations were already fulfilled, call to Query 'SELECT COUNT(*) FROM \"user_accounts\" WHERE (\"user_accounts\".\"email\" = $1) LIMIT 1;' with args [{Name: Ordinal:1 Value:internal-error-email@example.com}] was not expected"),
+			ExpectedErr:   InternalErrorCheckEmail,
 		},
 	}
 
Index: api/internal/repository/orm/boil_table_names.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.\r\n// This file is meant to be re-generated in place and/or deleted at any time.\r\n\r\npackage orm\r\n\r\nvar TableNames = struct {\r\n\tUserAccounts string\r\n}{\r\n\tUserAccounts: \"user_accounts\",\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/internal/repository/orm/boil_table_names.go b/api/internal/repository/orm/boil_table_names.go
--- a/api/internal/repository/orm/boil_table_names.go	(revision 16bdd12a1d72b35622c8ef226fccdc68eeb14ec5)
+++ b/api/internal/repository/orm/boil_table_names.go	(date 1699237267978)
@@ -4,7 +4,9 @@
 package orm
 
 var TableNames = struct {
+	Friendships  string
 	UserAccounts string
 }{
+	Friendships:  "friendships",
 	UserAccounts: "user_accounts",
 }
Index: api/internal/repository/orm/user_accounts.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.\r\n// This file is meant to be re-generated in place and/or deleted at any time.\r\n\r\npackage orm\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"database/sql\"\r\n\t\"fmt\"\r\n\t\"reflect\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n\t\"sync\"\r\n\t\"time\"\r\n\r\n\t\"github.com/friendsofgo/errors\"\r\n\t\"github.com/volatiletech/sqlboiler/v4/boil\"\r\n\t\"github.com/volatiletech/sqlboiler/v4/queries\"\r\n\t\"github.com/volatiletech/sqlboiler/v4/queries/qm\"\r\n\t\"github.com/volatiletech/sqlboiler/v4/queries/qmhelper\"\r\n\t\"github.com/volatiletech/strmangle\"\r\n)\r\n\r\n// UserAccount is an object representing the database table.\r\ntype UserAccount struct {\r\n\tUserID int    `boil:\"user_id\" json:\"user_id\" toml:\"user_id\" yaml:\"user_id\"`\r\n\tName   string `boil:\"name\" json:\"name\" toml:\"name\" yaml:\"name\"`\r\n\tEmail  string `boil:\"email\" json:\"email\" toml:\"email\" yaml:\"email\"`\r\n\r\n\tR *userAccountR `boil:\"-\" json:\"-\" toml:\"-\" yaml:\"-\"`\r\n\tL userAccountL  `boil:\"-\" json:\"-\" toml:\"-\" yaml:\"-\"`\r\n}\r\n\r\nvar UserAccountColumns = struct {\r\n\tUserID string\r\n\tName   string\r\n\tEmail  string\r\n}{\r\n\tUserID: \"user_id\",\r\n\tName:   \"name\",\r\n\tEmail:  \"email\",\r\n}\r\n\r\nvar UserAccountTableColumns = struct {\r\n\tUserID string\r\n\tName   string\r\n\tEmail  string\r\n}{\r\n\tUserID: \"user_accounts.user_id\",\r\n\tName:   \"user_accounts.name\",\r\n\tEmail:  \"user_accounts.email\",\r\n}\r\n\r\n// Generated where\r\n\r\ntype whereHelperint struct{ field string }\r\n\r\nfunc (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }\r\nfunc (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }\r\nfunc (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }\r\nfunc (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }\r\nfunc (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }\r\nfunc (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }\r\nfunc (w whereHelperint) IN(slice []int) qm.QueryMod {\r\n\tvalues := make([]interface{}, 0, len(slice))\r\n\tfor _, value := range slice {\r\n\t\tvalues = append(values, value)\r\n\t}\r\n\treturn qm.WhereIn(fmt.Sprintf(\"%s IN ?\", w.field), values...)\r\n}\r\nfunc (w whereHelperint) NIN(slice []int) qm.QueryMod {\r\n\tvalues := make([]interface{}, 0, len(slice))\r\n\tfor _, value := range slice {\r\n\t\tvalues = append(values, value)\r\n\t}\r\n\treturn qm.WhereNotIn(fmt.Sprintf(\"%s NOT IN ?\", w.field), values...)\r\n}\r\n\r\ntype whereHelperstring struct{ field string }\r\n\r\nfunc (w whereHelperstring) EQ(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.EQ, x) }\r\nfunc (w whereHelperstring) NEQ(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.NEQ, x) }\r\nfunc (w whereHelperstring) LT(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.LT, x) }\r\nfunc (w whereHelperstring) LTE(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.LTE, x) }\r\nfunc (w whereHelperstring) GT(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.GT, x) }\r\nfunc (w whereHelperstring) GTE(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.GTE, x) }\r\nfunc (w whereHelperstring) LIKE(x string) qm.QueryMod   { return qm.Where(w.field+\" LIKE ?\", x) }\r\nfunc (w whereHelperstring) NLIKE(x string) qm.QueryMod  { return qm.Where(w.field+\" NOT LIKE ?\", x) }\r\nfunc (w whereHelperstring) ILIKE(x string) qm.QueryMod  { return qm.Where(w.field+\" ILIKE ?\", x) }\r\nfunc (w whereHelperstring) NILIKE(x string) qm.QueryMod { return qm.Where(w.field+\" NOT ILIKE ?\", x) }\r\nfunc (w whereHelperstring) IN(slice []string) qm.QueryMod {\r\n\tvalues := make([]interface{}, 0, len(slice))\r\n\tfor _, value := range slice {\r\n\t\tvalues = append(values, value)\r\n\t}\r\n\treturn qm.WhereIn(fmt.Sprintf(\"%s IN ?\", w.field), values...)\r\n}\r\nfunc (w whereHelperstring) NIN(slice []string) qm.QueryMod {\r\n\tvalues := make([]interface{}, 0, len(slice))\r\n\tfor _, value := range slice {\r\n\t\tvalues = append(values, value)\r\n\t}\r\n\treturn qm.WhereNotIn(fmt.Sprintf(\"%s NOT IN ?\", w.field), values...)\r\n}\r\n\r\nvar UserAccountWhere = struct {\r\n\tUserID whereHelperint\r\n\tName   whereHelperstring\r\n\tEmail  whereHelperstring\r\n}{\r\n\tUserID: whereHelperint{field: \"\\\"user_accounts\\\".\\\"user_id\\\"\"},\r\n\tName:   whereHelperstring{field: \"\\\"user_accounts\\\".\\\"name\\\"\"},\r\n\tEmail:  whereHelperstring{field: \"\\\"user_accounts\\\".\\\"email\\\"\"},\r\n}\r\n\r\n// UserAccountRels is where relationship names are stored.\r\nvar UserAccountRels = struct {\r\n}{}\r\n\r\n// userAccountR is where relationships are stored.\r\ntype userAccountR struct {\r\n}\r\n\r\n// NewStruct creates a new relationship struct\r\nfunc (*userAccountR) NewStruct() *userAccountR {\r\n\treturn &userAccountR{}\r\n}\r\n\r\n// userAccountL is where Load methods for each relationship are stored.\r\ntype userAccountL struct{}\r\n\r\nvar (\r\n\tuserAccountAllColumns            = []string{\"user_id\", \"name\", \"email\"}\r\n\tuserAccountColumnsWithoutDefault = []string{\"name\", \"email\"}\r\n\tuserAccountColumnsWithDefault    = []string{\"user_id\"}\r\n\tuserAccountPrimaryKeyColumns     = []string{\"user_id\"}\r\n\tuserAccountGeneratedColumns      = []string{}\r\n)\r\n\r\ntype (\r\n\t// UserAccountSlice is an alias for a slice of pointers to UserAccount.\r\n\t// This should almost always be used instead of []UserAccount.\r\n\tUserAccountSlice []*UserAccount\r\n\r\n\tuserAccountQuery struct {\r\n\t\t*queries.Query\r\n\t}\r\n)\r\n\r\n// Cache for insert, update and upsert\r\nvar (\r\n\tuserAccountType                 = reflect.TypeOf(&UserAccount{})\r\n\tuserAccountMapping              = queries.MakeStructMapping(userAccountType)\r\n\tuserAccountPrimaryKeyMapping, _ = queries.BindMapping(userAccountType, userAccountMapping, userAccountPrimaryKeyColumns)\r\n\tuserAccountInsertCacheMut       sync.RWMutex\r\n\tuserAccountInsertCache          = make(map[string]insertCache)\r\n\tuserAccountUpdateCacheMut       sync.RWMutex\r\n\tuserAccountUpdateCache          = make(map[string]updateCache)\r\n\tuserAccountUpsertCacheMut       sync.RWMutex\r\n\tuserAccountUpsertCache          = make(map[string]insertCache)\r\n)\r\n\r\nvar (\r\n\t// Force time package dependency for automated UpdatedAt/CreatedAt.\r\n\t_ = time.Second\r\n\t// Force qmhelper dependency for where clause generation (which doesn't\r\n\t// always happen)\r\n\t_ = qmhelper.Where\r\n)\r\n\r\n// One returns a single userAccount record from the query.\r\nfunc (q userAccountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*UserAccount, error) {\r\n\to := &UserAccount{}\r\n\r\n\tqueries.SetLimit(q.Query, 1)\r\n\r\n\terr := q.Bind(ctx, exec, o)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, sql.ErrNoRows\r\n\t\t}\r\n\t\treturn nil, errors.Wrap(err, \"orm: failed to execute a one query for user_accounts\")\r\n\t}\r\n\r\n\treturn o, nil\r\n}\r\n\r\n// All returns all UserAccount records from the query.\r\nfunc (q userAccountQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserAccountSlice, error) {\r\n\tvar o []*UserAccount\r\n\r\n\terr := q.Bind(ctx, exec, &o)\r\n\tif err != nil {\r\n\t\treturn nil, errors.Wrap(err, \"orm: failed to assign all query results to UserAccount slice\")\r\n\t}\r\n\r\n\treturn o, nil\r\n}\r\n\r\n// Count returns the count of all UserAccount records in the query.\r\nfunc (q userAccountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {\r\n\tvar count int64\r\n\r\n\tqueries.SetSelect(q.Query, nil)\r\n\tqueries.SetCount(q.Query)\r\n\r\n\terr := q.Query.QueryRowContext(ctx, exec).Scan(&count)\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: failed to count user_accounts rows\")\r\n\t}\r\n\r\n\treturn count, nil\r\n}\r\n\r\n// Exists checks if the row exists in the table.\r\nfunc (q userAccountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {\r\n\tvar count int64\r\n\r\n\tqueries.SetSelect(q.Query, nil)\r\n\tqueries.SetCount(q.Query)\r\n\tqueries.SetLimit(q.Query, 1)\r\n\r\n\terr := q.Query.QueryRowContext(ctx, exec).Scan(&count)\r\n\tif err != nil {\r\n\t\treturn false, errors.Wrap(err, \"orm: failed to check if user_accounts exists\")\r\n\t}\r\n\r\n\treturn count > 0, nil\r\n}\r\n\r\n// UserAccounts retrieves all the records using an executor.\r\nfunc UserAccounts(mods ...qm.QueryMod) userAccountQuery {\r\n\tmods = append(mods, qm.From(\"\\\"user_accounts\\\"\"))\r\n\tq := NewQuery(mods...)\r\n\tif len(queries.GetSelect(q)) == 0 {\r\n\t\tqueries.SetSelect(q, []string{\"\\\"user_accounts\\\".*\"})\r\n\t}\r\n\r\n\treturn userAccountQuery{q}\r\n}\r\n\r\n// FindUserAccount retrieves a single record by ID with an executor.\r\n// If selectCols is empty Find will return all columns.\r\nfunc FindUserAccount(ctx context.Context, exec boil.ContextExecutor, userID int, selectCols ...string) (*UserAccount, error) {\r\n\tuserAccountObj := &UserAccount{}\r\n\r\n\tsel := \"*\"\r\n\tif len(selectCols) > 0 {\r\n\t\tsel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), \",\")\r\n\t}\r\n\tquery := fmt.Sprintf(\r\n\t\t\"select %s from \\\"user_accounts\\\" where \\\"user_id\\\"=$1\", sel,\r\n\t)\r\n\r\n\tq := queries.Raw(query, userID)\r\n\r\n\terr := q.Bind(ctx, exec, userAccountObj)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, sql.ErrNoRows\r\n\t\t}\r\n\t\treturn nil, errors.Wrap(err, \"orm: unable to select from user_accounts\")\r\n\t}\r\n\r\n\treturn userAccountObj, nil\r\n}\r\n\r\n// Insert a single record using an executor.\r\n// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.\r\nfunc (o *UserAccount) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {\r\n\tif o == nil {\r\n\t\treturn errors.New(\"orm: no user_accounts provided for insertion\")\r\n\t}\r\n\r\n\tvar err error\r\n\r\n\tnzDefaults := queries.NonZeroDefaultSet(userAccountColumnsWithDefault, o)\r\n\r\n\tkey := makeCacheKey(columns, nzDefaults)\r\n\tuserAccountInsertCacheMut.RLock()\r\n\tcache, cached := userAccountInsertCache[key]\r\n\tuserAccountInsertCacheMut.RUnlock()\r\n\r\n\tif !cached {\r\n\t\twl, returnColumns := columns.InsertColumnSet(\r\n\t\t\tuserAccountAllColumns,\r\n\t\t\tuserAccountColumnsWithDefault,\r\n\t\t\tuserAccountColumnsWithoutDefault,\r\n\t\t\tnzDefaults,\r\n\t\t)\r\n\r\n\t\tcache.valueMapping, err = queries.BindMapping(userAccountType, userAccountMapping, wl)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tcache.retMapping, err = queries.BindMapping(userAccountType, userAccountMapping, returnColumns)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif len(wl) != 0 {\r\n\t\t\tcache.query = fmt.Sprintf(\"INSERT INTO \\\"user_accounts\\\" (\\\"%s\\\") %%sVALUES (%s)%%s\", strings.Join(wl, \"\\\",\\\"\"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))\r\n\t\t} else {\r\n\t\t\tcache.query = \"INSERT INTO \\\"user_accounts\\\" %sDEFAULT VALUES%s\"\r\n\t\t}\r\n\r\n\t\tvar queryOutput, queryReturning string\r\n\r\n\t\tif len(cache.retMapping) != 0 {\r\n\t\t\tqueryReturning = fmt.Sprintf(\" RETURNING \\\"%s\\\"\", strings.Join(returnColumns, \"\\\",\\\"\"))\r\n\t\t}\r\n\r\n\t\tcache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)\r\n\t}\r\n\r\n\tvalue := reflect.Indirect(reflect.ValueOf(o))\r\n\tvals := queries.ValuesFromMapping(value, cache.valueMapping)\r\n\r\n\tif boil.IsDebug(ctx) {\r\n\t\twriter := boil.DebugWriterFrom(ctx)\r\n\t\tfmt.Fprintln(writer, cache.query)\r\n\t\tfmt.Fprintln(writer, vals)\r\n\t}\r\n\r\n\tif len(cache.retMapping) != 0 {\r\n\t\terr = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)\r\n\t} else {\r\n\t\t_, err = exec.ExecContext(ctx, cache.query, vals...)\r\n\t}\r\n\r\n\tif err != nil {\r\n\t\treturn errors.Wrap(err, \"orm: unable to insert into user_accounts\")\r\n\t}\r\n\r\n\tif !cached {\r\n\t\tuserAccountInsertCacheMut.Lock()\r\n\t\tuserAccountInsertCache[key] = cache\r\n\t\tuserAccountInsertCacheMut.Unlock()\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\n// Update uses an executor to update the UserAccount.\r\n// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.\r\n// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.\r\nfunc (o *UserAccount) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {\r\n\tvar err error\r\n\tkey := makeCacheKey(columns, nil)\r\n\tuserAccountUpdateCacheMut.RLock()\r\n\tcache, cached := userAccountUpdateCache[key]\r\n\tuserAccountUpdateCacheMut.RUnlock()\r\n\r\n\tif !cached {\r\n\t\twl := columns.UpdateColumnSet(\r\n\t\t\tuserAccountAllColumns,\r\n\t\t\tuserAccountPrimaryKeyColumns,\r\n\t\t)\r\n\r\n\t\tif !columns.IsWhitelist() {\r\n\t\t\twl = strmangle.SetComplement(wl, []string{\"created_at\"})\r\n\t\t}\r\n\t\tif len(wl) == 0 {\r\n\t\t\treturn 0, errors.New(\"orm: unable to update user_accounts, could not build whitelist\")\r\n\t\t}\r\n\r\n\t\tcache.query = fmt.Sprintf(\"UPDATE \\\"user_accounts\\\" SET %s WHERE %s\",\r\n\t\t\tstrmangle.SetParamNames(\"\\\"\", \"\\\"\", 1, wl),\r\n\t\t\tstrmangle.WhereClause(\"\\\"\", \"\\\"\", len(wl)+1, userAccountPrimaryKeyColumns),\r\n\t\t)\r\n\t\tcache.valueMapping, err = queries.BindMapping(userAccountType, userAccountMapping, append(wl, userAccountPrimaryKeyColumns...))\r\n\t\tif err != nil {\r\n\t\t\treturn 0, err\r\n\t\t}\r\n\t}\r\n\r\n\tvalues := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)\r\n\r\n\tif boil.IsDebug(ctx) {\r\n\t\twriter := boil.DebugWriterFrom(ctx)\r\n\t\tfmt.Fprintln(writer, cache.query)\r\n\t\tfmt.Fprintln(writer, values)\r\n\t}\r\n\tvar result sql.Result\r\n\tresult, err = exec.ExecContext(ctx, cache.query, values...)\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: unable to update user_accounts row\")\r\n\t}\r\n\r\n\trowsAff, err := result.RowsAffected()\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: failed to get rows affected by update for user_accounts\")\r\n\t}\r\n\r\n\tif !cached {\r\n\t\tuserAccountUpdateCacheMut.Lock()\r\n\t\tuserAccountUpdateCache[key] = cache\r\n\t\tuserAccountUpdateCacheMut.Unlock()\r\n\t}\r\n\r\n\treturn rowsAff, nil\r\n}\r\n\r\n// UpdateAll updates all rows with the specified column values.\r\nfunc (q userAccountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {\r\n\tqueries.SetUpdate(q.Query, cols)\r\n\r\n\tresult, err := q.Query.ExecContext(ctx, exec)\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: unable to update all for user_accounts\")\r\n\t}\r\n\r\n\trowsAff, err := result.RowsAffected()\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: unable to retrieve rows affected for user_accounts\")\r\n\t}\r\n\r\n\treturn rowsAff, nil\r\n}\r\n\r\n// UpdateAll updates all rows with the specified column values, using an executor.\r\nfunc (o UserAccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {\r\n\tln := int64(len(o))\r\n\tif ln == 0 {\r\n\t\treturn 0, nil\r\n\t}\r\n\r\n\tif len(cols) == 0 {\r\n\t\treturn 0, errors.New(\"orm: update all requires at least one column argument\")\r\n\t}\r\n\r\n\tcolNames := make([]string, len(cols))\r\n\targs := make([]interface{}, len(cols))\r\n\r\n\ti := 0\r\n\tfor name, value := range cols {\r\n\t\tcolNames[i] = name\r\n\t\targs[i] = value\r\n\t\ti++\r\n\t}\r\n\r\n\t// Append all of the primary key values for each column\r\n\tfor _, obj := range o {\r\n\t\tpkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userAccountPrimaryKeyMapping)\r\n\t\targs = append(args, pkeyArgs...)\r\n\t}\r\n\r\n\tsql := fmt.Sprintf(\"UPDATE \\\"user_accounts\\\" SET %s WHERE %s\",\r\n\t\tstrmangle.SetParamNames(\"\\\"\", \"\\\"\", 1, colNames),\r\n\t\tstrmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userAccountPrimaryKeyColumns, len(o)))\r\n\r\n\tif boil.IsDebug(ctx) {\r\n\t\twriter := boil.DebugWriterFrom(ctx)\r\n\t\tfmt.Fprintln(writer, sql)\r\n\t\tfmt.Fprintln(writer, args...)\r\n\t}\r\n\tresult, err := exec.ExecContext(ctx, sql, args...)\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: unable to update all in userAccount slice\")\r\n\t}\r\n\r\n\trowsAff, err := result.RowsAffected()\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: unable to retrieve rows affected all in update all userAccount\")\r\n\t}\r\n\treturn rowsAff, nil\r\n}\r\n\r\n// Upsert attempts an insert using an executor, and does an update or ignore on conflict.\r\n// See boil.Columns documentation for how to properly use updateColumns and insertColumns.\r\nfunc (o *UserAccount) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {\r\n\tif o == nil {\r\n\t\treturn errors.New(\"orm: no user_accounts provided for upsert\")\r\n\t}\r\n\r\n\tnzDefaults := queries.NonZeroDefaultSet(userAccountColumnsWithDefault, o)\r\n\r\n\t// Build cache key in-line uglily - mysql vs psql problems\r\n\tbuf := strmangle.GetBuffer()\r\n\tif updateOnConflict {\r\n\t\tbuf.WriteByte('t')\r\n\t} else {\r\n\t\tbuf.WriteByte('f')\r\n\t}\r\n\tbuf.WriteByte('.')\r\n\tfor _, c := range conflictColumns {\r\n\t\tbuf.WriteString(c)\r\n\t}\r\n\tbuf.WriteByte('.')\r\n\tbuf.WriteString(strconv.Itoa(updateColumns.Kind))\r\n\tfor _, c := range updateColumns.Cols {\r\n\t\tbuf.WriteString(c)\r\n\t}\r\n\tbuf.WriteByte('.')\r\n\tbuf.WriteString(strconv.Itoa(insertColumns.Kind))\r\n\tfor _, c := range insertColumns.Cols {\r\n\t\tbuf.WriteString(c)\r\n\t}\r\n\tbuf.WriteByte('.')\r\n\tfor _, c := range nzDefaults {\r\n\t\tbuf.WriteString(c)\r\n\t}\r\n\tkey := buf.String()\r\n\tstrmangle.PutBuffer(buf)\r\n\r\n\tuserAccountUpsertCacheMut.RLock()\r\n\tcache, cached := userAccountUpsertCache[key]\r\n\tuserAccountUpsertCacheMut.RUnlock()\r\n\r\n\tvar err error\r\n\r\n\tif !cached {\r\n\t\tinsert, ret := insertColumns.InsertColumnSet(\r\n\t\t\tuserAccountAllColumns,\r\n\t\t\tuserAccountColumnsWithDefault,\r\n\t\t\tuserAccountColumnsWithoutDefault,\r\n\t\t\tnzDefaults,\r\n\t\t)\r\n\r\n\t\tupdate := updateColumns.UpdateColumnSet(\r\n\t\t\tuserAccountAllColumns,\r\n\t\t\tuserAccountPrimaryKeyColumns,\r\n\t\t)\r\n\r\n\t\tif updateOnConflict && len(update) == 0 {\r\n\t\t\treturn errors.New(\"orm: unable to upsert user_accounts, could not build update column list\")\r\n\t\t}\r\n\r\n\t\tconflict := conflictColumns\r\n\t\tif len(conflict) == 0 {\r\n\t\t\tconflict = make([]string, len(userAccountPrimaryKeyColumns))\r\n\t\t\tcopy(conflict, userAccountPrimaryKeyColumns)\r\n\t\t}\r\n\t\tcache.query = buildUpsertQueryPostgres(dialect, \"\\\"user_accounts\\\"\", updateOnConflict, ret, update, conflict, insert)\r\n\r\n\t\tcache.valueMapping, err = queries.BindMapping(userAccountType, userAccountMapping, insert)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif len(ret) != 0 {\r\n\t\t\tcache.retMapping, err = queries.BindMapping(userAccountType, userAccountMapping, ret)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn err\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvalue := reflect.Indirect(reflect.ValueOf(o))\r\n\tvals := queries.ValuesFromMapping(value, cache.valueMapping)\r\n\tvar returns []interface{}\r\n\tif len(cache.retMapping) != 0 {\r\n\t\treturns = queries.PtrsFromMapping(value, cache.retMapping)\r\n\t}\r\n\r\n\tif boil.IsDebug(ctx) {\r\n\t\twriter := boil.DebugWriterFrom(ctx)\r\n\t\tfmt.Fprintln(writer, cache.query)\r\n\t\tfmt.Fprintln(writer, vals)\r\n\t}\r\n\tif len(cache.retMapping) != 0 {\r\n\t\terr = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\terr = nil // Postgres doesn't return anything when there's no update\r\n\t\t}\r\n\t} else {\r\n\t\t_, err = exec.ExecContext(ctx, cache.query, vals...)\r\n\t}\r\n\tif err != nil {\r\n\t\treturn errors.Wrap(err, \"orm: unable to upsert user_accounts\")\r\n\t}\r\n\r\n\tif !cached {\r\n\t\tuserAccountUpsertCacheMut.Lock()\r\n\t\tuserAccountUpsertCache[key] = cache\r\n\t\tuserAccountUpsertCacheMut.Unlock()\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\n// Delete deletes a single UserAccount record with an executor.\r\n// Delete will match against the primary key column to find the record to delete.\r\nfunc (o *UserAccount) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {\r\n\tif o == nil {\r\n\t\treturn 0, errors.New(\"orm: no UserAccount provided for delete\")\r\n\t}\r\n\r\n\targs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userAccountPrimaryKeyMapping)\r\n\tsql := \"DELETE FROM \\\"user_accounts\\\" WHERE \\\"user_id\\\"=$1\"\r\n\r\n\tif boil.IsDebug(ctx) {\r\n\t\twriter := boil.DebugWriterFrom(ctx)\r\n\t\tfmt.Fprintln(writer, sql)\r\n\t\tfmt.Fprintln(writer, args...)\r\n\t}\r\n\tresult, err := exec.ExecContext(ctx, sql, args...)\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: unable to delete from user_accounts\")\r\n\t}\r\n\r\n\trowsAff, err := result.RowsAffected()\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: failed to get rows affected by delete for user_accounts\")\r\n\t}\r\n\r\n\treturn rowsAff, nil\r\n}\r\n\r\n// DeleteAll deletes all matching rows.\r\nfunc (q userAccountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {\r\n\tif q.Query == nil {\r\n\t\treturn 0, errors.New(\"orm: no userAccountQuery provided for delete all\")\r\n\t}\r\n\r\n\tqueries.SetDelete(q.Query)\r\n\r\n\tresult, err := q.Query.ExecContext(ctx, exec)\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: unable to delete all from user_accounts\")\r\n\t}\r\n\r\n\trowsAff, err := result.RowsAffected()\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: failed to get rows affected by deleteall for user_accounts\")\r\n\t}\r\n\r\n\treturn rowsAff, nil\r\n}\r\n\r\n// DeleteAll deletes all rows in the slice, using an executor.\r\nfunc (o UserAccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {\r\n\tif len(o) == 0 {\r\n\t\treturn 0, nil\r\n\t}\r\n\r\n\tvar args []interface{}\r\n\tfor _, obj := range o {\r\n\t\tpkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userAccountPrimaryKeyMapping)\r\n\t\targs = append(args, pkeyArgs...)\r\n\t}\r\n\r\n\tsql := \"DELETE FROM \\\"user_accounts\\\" WHERE \" +\r\n\t\tstrmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userAccountPrimaryKeyColumns, len(o))\r\n\r\n\tif boil.IsDebug(ctx) {\r\n\t\twriter := boil.DebugWriterFrom(ctx)\r\n\t\tfmt.Fprintln(writer, sql)\r\n\t\tfmt.Fprintln(writer, args)\r\n\t}\r\n\tresult, err := exec.ExecContext(ctx, sql, args...)\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: unable to delete all from userAccount slice\")\r\n\t}\r\n\r\n\trowsAff, err := result.RowsAffected()\r\n\tif err != nil {\r\n\t\treturn 0, errors.Wrap(err, \"orm: failed to get rows affected by deleteall for user_accounts\")\r\n\t}\r\n\r\n\treturn rowsAff, nil\r\n}\r\n\r\n// Reload refetches the object from the database\r\n// using the primary keys with an executor.\r\nfunc (o *UserAccount) Reload(ctx context.Context, exec boil.ContextExecutor) error {\r\n\tret, err := FindUserAccount(ctx, exec, o.UserID)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\t*o = *ret\r\n\treturn nil\r\n}\r\n\r\n// ReloadAll refetches every row with matching primary key column values\r\n// and overwrites the original object slice with the newly updated slice.\r\nfunc (o *UserAccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {\r\n\tif o == nil || len(*o) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tslice := UserAccountSlice{}\r\n\tvar args []interface{}\r\n\tfor _, obj := range *o {\r\n\t\tpkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userAccountPrimaryKeyMapping)\r\n\t\targs = append(args, pkeyArgs...)\r\n\t}\r\n\r\n\tsql := \"SELECT \\\"user_accounts\\\".* FROM \\\"user_accounts\\\" WHERE \" +\r\n\t\tstrmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userAccountPrimaryKeyColumns, len(*o))\r\n\r\n\tq := queries.Raw(sql, args...)\r\n\r\n\terr := q.Bind(ctx, exec, &slice)\r\n\tif err != nil {\r\n\t\treturn errors.Wrap(err, \"orm: unable to reload all in UserAccountSlice\")\r\n\t}\r\n\r\n\t*o = slice\r\n\r\n\treturn nil\r\n}\r\n\r\n// UserAccountExists checks if the UserAccount row exists.\r\nfunc UserAccountExists(ctx context.Context, exec boil.ContextExecutor, userID int) (bool, error) {\r\n\tvar exists bool\r\n\tsql := \"select exists(select 1 from \\\"user_accounts\\\" where \\\"user_id\\\"=$1 limit 1)\"\r\n\r\n\tif boil.IsDebug(ctx) {\r\n\t\twriter := boil.DebugWriterFrom(ctx)\r\n\t\tfmt.Fprintln(writer, sql)\r\n\t\tfmt.Fprintln(writer, userID)\r\n\t}\r\n\trow := exec.QueryRowContext(ctx, sql, userID)\r\n\r\n\terr := row.Scan(&exists)\r\n\tif err != nil {\r\n\t\treturn false, errors.Wrap(err, \"orm: unable to check if user_accounts exists\")\r\n\t}\r\n\r\n\treturn exists, nil\r\n}\r\n\r\n// Exists checks if the UserAccount row exists.\r\nfunc (o *UserAccount) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {\r\n\treturn UserAccountExists(ctx, exec, o.UserID)\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/internal/repository/orm/user_accounts.go b/api/internal/repository/orm/user_accounts.go
--- a/api/internal/repository/orm/user_accounts.go	(revision 16bdd12a1d72b35622c8ef226fccdc68eeb14ec5)
+++ b/api/internal/repository/orm/user_accounts.go	(date 1699237267989)
@@ -53,56 +53,6 @@
 
 // Generated where
 
-type whereHelperint struct{ field string }
-
-func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
-func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
-func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
-func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
-func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
-func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
-func (w whereHelperint) IN(slice []int) qm.QueryMod {
-	values := make([]interface{}, 0, len(slice))
-	for _, value := range slice {
-		values = append(values, value)
-	}
-	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
-}
-func (w whereHelperint) NIN(slice []int) qm.QueryMod {
-	values := make([]interface{}, 0, len(slice))
-	for _, value := range slice {
-		values = append(values, value)
-	}
-	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
-}
-
-type whereHelperstring struct{ field string }
-
-func (w whereHelperstring) EQ(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.EQ, x) }
-func (w whereHelperstring) NEQ(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
-func (w whereHelperstring) LT(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.LT, x) }
-func (w whereHelperstring) LTE(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.LTE, x) }
-func (w whereHelperstring) GT(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.GT, x) }
-func (w whereHelperstring) GTE(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.GTE, x) }
-func (w whereHelperstring) LIKE(x string) qm.QueryMod   { return qm.Where(w.field+" LIKE ?", x) }
-func (w whereHelperstring) NLIKE(x string) qm.QueryMod  { return qm.Where(w.field+" NOT LIKE ?", x) }
-func (w whereHelperstring) ILIKE(x string) qm.QueryMod  { return qm.Where(w.field+" ILIKE ?", x) }
-func (w whereHelperstring) NILIKE(x string) qm.QueryMod { return qm.Where(w.field+" NOT ILIKE ?", x) }
-func (w whereHelperstring) IN(slice []string) qm.QueryMod {
-	values := make([]interface{}, 0, len(slice))
-	for _, value := range slice {
-		values = append(values, value)
-	}
-	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
-}
-func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
-	values := make([]interface{}, 0, len(slice))
-	for _, value := range slice {
-		values = append(values, value)
-	}
-	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
-}
-
 var UserAccountWhere = struct {
 	UserID whereHelperint
 	Name   whereHelperstring
Index: api/internal/handler/add_user.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\r\n\r\nimport (\r\n\t\"assignment/internal/model\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\ntype User struct {\r\n\tName  string `json:\"name\"`\r\n\tEmail string `json:\"email\"`\r\n}\r\n\r\nfunc (h Handler) AddUsers() gin.HandlerFunc {\r\n\r\n\treturn func(c *gin.Context) {\r\n\t\tvar input User\r\n\t\tif err := c.ShouldBindJSON(&input); err != nil {\r\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to get your information\"})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif err := input.validate(); err != nil {\r\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif err := h.ctrl.AddUsers(c.Request.Context(),\r\n\t\t\tmodel.User{\r\n\t\t\t\tName:  input.Name,\r\n\t\t\t\tEmail: input.Email,\r\n\t\t\t}); err != nil {\r\n\t\t\tCustomError(c, err)\r\n\t\t\treturn\r\n\t\t}\r\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Add user successfully!\"})\r\n\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/internal/handler/add_user.go b/api/internal/handler/add_user.go
--- a/api/internal/handler/add_user.go	(revision 16bdd12a1d72b35622c8ef226fccdc68eeb14ec5)
+++ b/api/internal/handler/add_user.go	(date 1699237267998)
@@ -13,7 +13,6 @@
 }
 
 func (h Handler) AddUsers() gin.HandlerFunc {
-
 	return func(c *gin.Context) {
 		var input User
 		if err := c.ShouldBindJSON(&input); err != nil {
Index: .idea/sqldialects.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"SqlDialectMappings\">\r\n    <file url=\"file://$PROJECT_DIR$/api/data/migration/0001_init.up.sql\" dialect=\"GenericSQL\" />\r\n    <file url=\"file://$PROJECT_DIR$/api/internal/repository/testdata/testdata_for_user_accounts.sql\" dialect=\"GenericSQL\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/sqldialects.xml b/.idea/sqldialects.xml
--- a/.idea/sqldialects.xml	(revision 16bdd12a1d72b35622c8ef226fccdc68eeb14ec5)
+++ b/.idea/sqldialects.xml	(date 1699237268007)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="SqlDialectMappings">
-    <file url="file://$PROJECT_DIR$/api/data/migration/0001_init.up.sql" dialect="GenericSQL" />
+    <file url="file://$PROJECT_DIR$/api/data/migration/0001_init.up.sql" dialect="PostgreSQL" />
     <file url="file://$PROJECT_DIR$/api/internal/repository/testdata/testdata_for_user_accounts.sql" dialect="GenericSQL" />
   </component>
 </project>
\ No newline at end of file
Index: api/internal/repository/add_user_test.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package repository\r\n\r\nimport (\r\n\t\"assignment/internal/model\"\r\n\t\"assignment/internal/repository/testdata\"\r\n\t\"context\"\r\n\t\"database/sql\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/DATA-DOG/go-sqlmock\"\r\n\t\"github.com/friendsofgo/errors\"\r\n\t\"github.com/stretchr/testify/require\"\r\n)\r\n\r\nfunc TestImpl_AddUserToDatabase(t *testing.T) {\r\n\r\n\ttestCases := []struct {\r\n\t\tName        string\r\n\t\tUser        model.User\r\n\t\tExpectedErr error\r\n\t\tWantDBFail  bool\r\n\t}{\r\n\t\t{\r\n\t\t\tName:        \"Success\",\r\n\t\t\tUser:        model.User{Name: \"NewUser\", Email: \"new-user-email@example.com\"},\r\n\t\t\tExpectedErr: nil,\r\n\t\t\tWantDBFail:  false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tName:        \"Error\",\r\n\t\t\tUser:        model.User{Name: \"AlreadyExistUser\", Email: \"already-exist-email@example.com\"},\r\n\t\t\tExpectedErr: errors.New(\"orm: unable to insert into user_accounts: pq: duplicate key value violates unique constraint \\\"user_accounts_email_key\\\"\"),\r\n\t\t\tWantDBFail:  false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tName:        \"Internal Server Error\",\r\n\t\t\tUser:        model.User{Name: \"InternalErrorUser\", Email: \"internal-error-email@example.com\"},\r\n\t\t\tExpectedErr: errors.New(\"orm: unable to insert into user_accounts: all expectations were already fulfilled, call to Query 'INSERT INTO \\\"user_accounts\\\" (\\\"name\\\",\\\"email\\\") VALUES ($1,$2) RETURNING \\\"user_id\\\"' with args [{Name: Ordinal:1 Value:InternalErrorUser} {Name: Ordinal:2 Value:internal-error-email@example.com}] was not expected\"),\r\n\t\t\tWantDBFail:  true,\r\n\t\t},\r\n\t}\r\n\r\n\tctx := context.Background()\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.Name, func(t *testing.T) {\r\n\r\n\t\t\ttestdata.TestDatabase(t, func(tx *sql.Tx) {\r\n\r\n\t\t\t\ttestdata.LoadTestSQLFile(t, tx, \"testdata/testdata_for_user_accounts.sql\")\r\n\r\n\t\t\t\trepo := New(tx)\r\n\r\n\t\t\t\tif tc.WantDBFail {\r\n\t\t\t\t\tdbMock, _, _ := sqlmock.New()\r\n\t\t\t\t\trepo = New(dbMock)\r\n\t\t\t\t}\r\n\r\n\t\t\t\terr := repo.AddUser(ctx, tc.User)\r\n\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\trequire.EqualError(t, err, tc.ExpectedErr.Error())\r\n\t\t\t\t} else {\r\n\t\t\t\t\trequire.Equal(t, err, tc.ExpectedErr)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/internal/repository/add_user_test.go b/api/internal/repository/add_user_test.go
--- a/api/internal/repository/add_user_test.go	(revision 16bdd12a1d72b35622c8ef226fccdc68eeb14ec5)
+++ b/api/internal/repository/add_user_test.go	(date 1699237268017)
@@ -8,7 +8,6 @@
 	"testing"
 
 	"github.com/DATA-DOG/go-sqlmock"
-	"github.com/friendsofgo/errors"
 	"github.com/stretchr/testify/require"
 )
 
@@ -29,13 +28,13 @@
 		{
 			Name:        "Error",
 			User:        model.User{Name: "AlreadyExistUser", Email: "already-exist-email@example.com"},
-			ExpectedErr: errors.New("orm: unable to insert into user_accounts: pq: duplicate key value violates unique constraint \"user_accounts_email_key\""),
+			ExpectedErr: UserAlreadyExist,
 			WantDBFail:  false,
 		},
 		{
 			Name:        "Internal Server Error",
 			User:        model.User{Name: "InternalErrorUser", Email: "internal-error-email@example.com"},
-			ExpectedErr: errors.New("orm: unable to insert into user_accounts: all expectations were already fulfilled, call to Query 'INSERT INTO \"user_accounts\" (\"name\",\"email\") VALUES ($1,$2) RETURNING \"user_id\"' with args [{Name: Ordinal:1 Value:InternalErrorUser} {Name: Ordinal:2 Value:internal-error-email@example.com}] was not expected"),
+			ExpectedErr: InternalErrorAddUser,
 			WantDBFail:  true,
 		},
 	}
Index: api/internal/repository/new.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package repository\r\n\r\nimport (\r\n\t\"assignment/internal/model\"\r\n\t\"context\"\r\n\r\n\t\"github.com/volatiletech/sqlboiler/v4/boil\"\r\n)\r\n\r\ntype Repository interface {\r\n\tAddUser(ctx context.Context, user model.User) error\r\n\tCheckUserByEmail(ctx context.Context, userEmails string) (bool, error)\r\n}\r\n\r\ntype RepoImplement struct {\r\n\tpgConn boil.ContextExecutor\r\n}\r\n\r\nfunc New(pgConn boil.ContextExecutor) Repository {\r\n\treturn RepoImplement{pgConn: pgConn}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/internal/repository/new.go b/api/internal/repository/new.go
--- a/api/internal/repository/new.go	(revision 16bdd12a1d72b35622c8ef226fccdc68eeb14ec5)
+++ b/api/internal/repository/new.go	(date 1699237268027)
@@ -8,8 +8,10 @@
 )
 
 type Repository interface {
-	AddUser(ctx context.Context, user model.User) error
-	CheckUserByEmail(ctx context.Context, userEmails string) (bool, error)
+	AddUser(context.Context, model.User) error
+	CheckUserByEmail(context.Context, string) (bool, error)
+	AddFriendship(context.Context, []string) error
+	CheckFriendship(context.Context, []string) (bool, error)
 }
 
 type RepoImplement struct {
